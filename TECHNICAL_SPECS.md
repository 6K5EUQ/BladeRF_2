# BladeRF Wideband Spectrum Sweeper - 기술 스펙

## 1. 시스템 아키텍처

```
┌─────────────────────────────────────────────────────┐
│  BladeRF 2.0 micro xA9                              │
│  (AD9361 Transceiver)                               │
└────────────────┬────────────────────────────────────┘
                 │ USB 3.0
                 ▼
┌─────────────────────────────────────────────────────┐
│  BladeRF Sweep Thread                               │
│  ┌───────────────────────────────────────────────┐  │
│  │ 1. 주파수 설정 (47MHz ~ 6GHz, 97 청크)       │  │
│  │ 2. IQ 샘플 수집 (61.44 MSPS, 10.3ms/청크)   │  │
│  │ 3. Hann 윈도우 적용                         │  │
│  │ 4. FFTW3 FFT 계산 (8192-bin)                │  │
│  │ 5. 전력 스펙트럼 → dB 변환                   │  │
│  │ 6. 누적 버퍼 업데이트                       │  │
│  │ 7. 워터폴에 행 추가                         │  │
│  └───────────────────────────────────────────────┘  │
└────────────────┬────────────────────────────────────┘
                 │ Mutex-protected
                 ▼
┌─────────────────────────────────────────────────────┐
│  OpenGL Rendering Thread (Main Thread)              │
│  ┌───────────────────────────────────────────────┐  │
│  │ 1. 스펙트럼 데이터 복사                      │  │
│  │ 2. 그리드 & 배경 렌더링                      │  │
│  │ 3. 스펙트럼 라인 그리기                      │  │
│  │ 4. 워터폴 칼라맵 렌더링                      │  │
│  │ 5. 축 레이블 텍스트 렌더링                  │  │
│  │ 6. 제어판 정보 표시                         │  │
│  │ 7. 프레임 스왑                              │  │
│  └───────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────┘
```

## 2. 주파수 스윕 설정

### 주파수 분할

| 항목 | 값 |
|---|---|
| **시작 주파수** | 47.0 MHz |
| **종료 주파수** | 6000.0 MHz |
| **주파수 범위** | 5953.0 MHz |
| **샘플 레이트** | 61.44 MSPS (고정) |
| **유효 대역폭** | ~61.44 MHz/청크 |
| **청크 개수** | ceil(5953 / 61.44) = **97개** |
| **청크 간격** | 61.44 MHz |

### 시간 계산

```
전체 스윕 주기: 1.0초
청크 당 시간: 1000ms / 97 = 10.309ms
샘플 수/청크: 61.44MHz × 10.309ms = 632,896샘플
```

### 각 청크의 중심 주파수

```python
# 계산 수식
for i in range(97):
    freq_mhz = 47.0 + (i + 0.5) * (5953.0 / 97)
    center_freq[i] = uint64_t(freq_mhz * 1e6)

# 예시:
# 청크 0:   center = 47 + 30.7 = 77.7 MHz
# 청크 48:  center = 47 + 3000 = 3047 MHz (3 GHz 근처)
# 청크 96:  center = 47 + 5953 - 30.7 = 5969 MHz
```

## 3. FFT 처리

### FFT 파라미터

| 항목 | 값 |
|---|---|
| **FFT 크기** | 8192 bins |
| **윈도우 함수** | Hann |
| **입력 포맷** | SC16_Q11 (16-bit signed) |
| **출력 포맷** | 32-bit float (dB) |
| **FFT 계산 시간** | ~2-5ms (FFTW3 최적화) |

### 주파수 해상도

```
해상도 = 샘플레이트 / FFT크기
       = 61.44MHz / 8192
       = 7.495 kHz/bin
```

### FFT 빈과 주파수 매핑

```
FFT 출력 빈 → 주파수 매핑

bin 0:    center_freq - (sample_rate/2)
bin k:    center_freq - (sample_rate/2) + k*(sample_rate/FFT_SIZE)
bin 8191: center_freq + (sample_rate/2) - resolution

예: 청크 0 (center = 77.7 MHz, rate = 61.44 MHz)
bin 0:    77.7 - 30.72 = 46.98 MHz  ✓
bin 4096: 77.7 MHz (중심)
bin 8191: 77.7 + 30.72 - 0.0075 = 108.41 MHz ✓
```

## 4. 메모리 구조

### 누적 스펙트럼 버퍼

```c++
std::vector<std::vector<float>> cumulative_spectrum;
// 크기: 97 청크 × 8192 bins × 4 bytes
//     = 3,178,496 bytes ≈ 3.03 MB
```

### 워터폴 순환 버퍼

```c++
std::queue<std::vector<float>> waterfall;
// 각 행: 97 청크 × 8192 bins × 4 bytes = 3.03 MB
// 최대 행: 5초 / 1초 = 5행
// 최대 메모리: 5 × 3.03 MB ≈ 15.15 MB

// 실제 구조:
// - 스윕 완료 후 전체 스펙트럼(797,184 bins)이 1행으로 추가됨
// - 오래된 행부터 자동 제거
```

### 총 메모리 요구사항

```
누적 스펙트럼:     ~3.03 MB
워터폴 (5행):     ~15.15 MB
FFT 버퍼:         ~0.5 MB
IQ 캡처 버퍼:     ~5 MB (per chunk)
기타:             ~1-2 MB
─────────────────────────
총합:             ~25 MB (보수적 추정)
```

## 5. 스레드 동기화

### BladeRF 스레드 (별도 스레드)

```cpp
while (running) {
    for (int chunk_idx = 0; chunk_idx < num_chunks; chunk_idx++) {
        // 1. 주파수 설정
        bladerf_set_frequency(dev, CHANNEL, chunk_freq);
        
        // 2. IQ 수집 (non-blocking)
        bladerf_sync_rx(dev, iq_buffer, samples, ...);
        
        // 3. FFT 계산 (CPU-bound)
        power_spectrum = compute_power_spectrum(iq_buffer);
        
        // 4. Mutex로 보호된 상태 업데이트
        {
            std::lock_guard<std::mutex> lock(mutex);
            cumulative_spectrum[chunk_idx] = power_spectrum;
        }
    }
    
    // 5. 스윕 완료 후 워터폴 업데이트
    {
        std::lock_guard<std::mutex> lock(mutex);
        waterfall.push(full_spectrum);
        while (waterfall.size() > waterfall_max_rows) {
            waterfall.pop();
        }
    }
}
```

### OpenGL 렌더링 스레드 (메인 스레드)

```cpp
while (!should_close) {
    // 1. 뮤텍스로 데이터 복사 (짧은 임계 구간)
    {
        std::lock_guard<std::mutex> lock(mutex);
        local_spectrum = cumulative_spectrum;
        local_waterfall = waterfall;
    }
    
    // 2. 렌더링 (뮤텍스 없음)
    glClear(...);
    draw_spectrum(local_spectrum);
    draw_waterfall(local_waterfall);
    draw_labels();
    glfwSwapBuffers();
}
```

### 뮤텍스 경합 분석

| 작업 | 소유권 기간 | 빈도 |
|---|---|---|
| 누적 스펙트럼 업데이트 | ~0.1ms | 97회/초 |
| 워터폴 추가 | ~0.5ms | 1회/초 |
| 렌더링 데이터 복사 | ~1ms | 60회/초 |
| **최대 대기 시간** | **~2ms** | - |

→ 무시할 수 있는 수준의 경합

## 6. 렌더링 시각화

### 스펙트럼 영역 (상단 50%)

```
┌────────────────────────────────────────────────┐
│  dB                                            │
│  0 │────────────────────────────────────────  │
│    │    ╱╲        ╱╲                          │
│ -20│   ╱  ╲  ╱╲  ╱  ╲                        │
│    │  ╱    ╲╱  ╲╱    ╲                      │
│ -40│ ╱                ╲   ╱╲                 │
│    │╱                  ╲ ╱  ╲               │
│ -60├─────────────────────────────────────── │
│    │
│    └────────────────────────────────────────┘
│      47MHz        3GHz          6GHz
└────────────────────────────────────────────────┘
  주파수 축 (로그스케일 아님, 선형)
```

### 워터폴 영역 (하단 50%)

```
┌────────────────────────────────────────────────┐
│ 새로운 데이터 (0.2초 전)                       │
│ ██████████ ← 최신 스윕 (파란색)                 │
│ ██████████ ← 0.2초 전                         │
│ ██████████ ← 0.4초 전                         │
│ ██████████ ← 0.6초 전                         │
│ ██████████ ← 0.8초 전 (빨간색)                │
│ 오래된 데이터                                   │
└────────────────────────────────────────────────┘
  칼라 맵: 파랑 → 초록 → 노랑 → 빨강 (power increase)
```

### 칼라맵 (Jet-like)

```
Power (normalized 0~1) → RGB

0.0  (0%)  : Blue   (0.5, 0, 0.5)
0.125(12%) : Cyan   (0, 0.5, 1.0)
0.375(38%) : Green  (0, 1.0, 1.0)
0.625(62%) : Yellow (1.0, 1.0, 0)
0.875(88%) : Red    (1.0, 0.5, 0)
1.0 (100%) : Dark Red (1.0, 0, 0)
```

## 7. 키 입력 처리

| 키 | 동작 | 효과 |
|---|---|---|
| W | `db_max += 5` | 최대값 증가 (동적 범위 확대) |
| S | `db_max -= 5` | 최대값 감소 (동적 범위 축소) |
| A | `db_min -= 5` | 최소값 감소 (더 약한 신호 표시) |
| D | `db_min += 5` | 최소값 증가 (더 강한 신호 중점) |
| UP | `zoom *= 1.1` | 확대 (미래 사용) |
| DOWN | `zoom /= 1.1` | 축소 (미래 사용) |
| R | Reset all | 모든 설정을 초기값으로 |
| ESC | Exit | 프로그램 종료 |

## 8. 성능 지표

### CPU 사용률 분석

```
BladeRF 스레드:
  - USB 데이터 수집:     ~30% (I/O 대기)
  - FFT 계산:           ~40% (FFTW 최적화)
  - 메모리 작업:        ~10%
  - 합계:               ~40-50% (단일 코어)

OpenGL 스레드:
  - 데이터 복사:        ~5%
  - 렌더링:            ~20% (GPU 가속)
  - 프레임 스왑:       ~5%
  - 합계:              ~20-30% (단일 코어)

전체: ~60-80% (멀티코어 활용)
```

### 메모리 접근 패턴

```
BladeRF 스레드:
  - 순차 읽기: IQ 버퍼 (632KB, L3 캐시 적중률 높음)
  - 랜덤 쓰기: FFT 출력 (32KB, L1 캐시 적중률 높음)
  - 동기화: Mutex (매우 짧은 임계 구간)

렌더링 스레드:
  - 순차 읽기: 워터폴 (메모리 효율적)
  - GPU 전송: PCIe (GPU가 대부분 처리)
```

### 대역폭 요구사항

```
USB 3.0 대역폭 요구:
  - 데이터 레이트: 61.44 MSPS × 4 bytes = 245.76 MB/s
  - USB 3.0 이론 최대: 400 MB/s
  - 사용률: 245.76 / 400 = 61.4% ✓ (여유 있음)

PCIe 대역폭 (GPU):
  - 스펙트럼 데이터: ~3 MB/frame × 100 FPS = 300 MB/s
  - PCIe 3.0 x16: 16 GB/s ✓ (문제 없음)
```

## 9. 타이밍 분석

### 청크 처리 흐름

```
Time (ms)  |  Event
───────────┼──────────────────────────────────────
   0.00    │  청크 0 시작 (freq = 77.7 MHz)
           │    ├─ 주파수 설정: 1ms
           │    ├─ 안정화 대기: 1ms
           │    ├─ IQ 샘플 수집: 6-8ms
           │    └─ FFT 계산: 2-3ms
  10.31    │  청크 1 시작 (freq = 108.4 MHz)
           │    [동일 과정 반복]
         ...
 1000.00   │  전체 스윕 완료 (모든 97개 청크)
           │    └─ 워터폴에 행 추가
 1000.00   │  새로운 스윕 사이클 시작
```

### FFT 성능

```
FFTW3 8192-point FFT (single precision):
  - 첫 실행 (계획 수립): ~50ms
  - 이후 실행 (캐시됨): ~2-3ms
  - 처리량: 약 2.7-4 million FFT/sec (단일 코어)
```

## 10. 향후 최적화 가능성

### 1. FPGA 기반 FFT (xA9 FPGA)
```
목표: 현재 PC FFT → BladeRF FPGA로 이동
- 성능: USB 대역폭 50% 감소
- 레이턴시: ~1ms 감소
- 복잡도: 높음
```

### 2. 주파수 영역 줌
```
구현: 특정 주파수 대역에 대한 고해상도 스캔
- 선택한 대역을 더 많은 청크로 분할
- 동시에 나머지 대역은 저해상도 유지
```

### 3. 신호 감지 알고리즘
```
추가: CFAR (Constant False Alarm Rate)
- 배경 노이즈 추정
- 피크 감지
- 신호 강도 경보
```

---

**작성**: DSA Spectrum Analysis Team  
**최종 업데이트**: 2026-02-11
